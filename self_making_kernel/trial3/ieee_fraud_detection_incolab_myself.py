# -*- coding: utf-8 -*-
"""ieee_fraud_detection_inColab_myself.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PvguPmyV7g37k9oFSBD_rBdDAkTACcCK

# 구글 드라이브와 Colab 연동
"""

from google.colab import auth
auth.authenticate_user()

from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)

!ls "/content/gdrive/"

!ls "/content/gdrive/My Drive/"

!cd "/content/gdrive/My Drive/"

!pwd

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline


from lightgbm import LGBMClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score

import os

"""# 메모리크기 줄이기

[참고커널] [Leonardo Ferreira](https://www.kaggle.com/kabure/extensive-eda-and-modeling-xgb-hyperopt)
"""

def reduce_memory_use(df, verbose=True):
  numerics=['int16','int32', 'int64', 'float16', 'float32', 'float64']
  start_mem = df.memory_usage().sum()/1024**2
  for col in df.columns:
    col_type= df[col].dtypes
    if col_type in numerics:
      c_min = df[col].min() #df[컬럼] 최솟값
      c_max = df[col].max() #df[컬럼] 최댓값
      if str(col_type)[:3]=='int': #컬럼 타입이 int16~ int64 타입일때
        if c_min>np.iinfo(np.int8).min and c_max<np.iinfo(np.int8).max:
          df[col]= df[col].astype(np.int8) #int8로 전환
        elif c_min>np.iinfo(np.int16).min and c_max<np.iinfo(np.int16).max:
          df[col]= df[col].astype(np.int16) #int16으로 전환

        elif c_min>np.iinfo(np.int32).min and c_max<np.iinfo(np.int32).max:
          df[col]= df[col].astype(np.int32) #int32으로 전환

        elif c_min>np.iinfo(np.int64).min and c_max<np.iinfo(np.int64).max:
          df[col]= df[col].astype(np.int64) #int64으로 전환

      else: #str(col_type)[:3]!='int' => float타입
        if c_min>np.finfo(np.float16).min and c_max<np.finfo(np.float16).max:
          df[col]= df[col].astype(np.float16) #float16으로 전환

        elif c_min>np.finfo(np.float32).min and c_max<np.finfo(np.float32).max:
          df[col]= df[col].astype(np.float32) #float32으로 전환

        elif c_min>np.finfo(np.float64).min and c_max<np.finfo(np.float64).max:
          df[col]= df[col].astype(np.float64) #float64으로 전환

  end_mem = df.memory_usage().sum()/ 1024**2
  if verbose:
    print('Memory usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format( end_mem, 100*(start_mem -end_mem)/start_mem))
  return df

"""# 데이터셋 읽기"""

train_transaction=pd.read_csv('/content/gdrive/My Drive/data/train_transaction.csv')
train_identity = pd.read_csv('/content/gdrive/My Drive/data/train_identity.csv')

# test 데이터 읽기
test_transaction = pd.read_csv('/content/gdrive/My Drive/data/test_transaction.csv')
test_identity = pd.read_csv('/content/gdrive/My Drive/data/test_identity.csv')

# reduce_memory_use() 함수를 이용하여 데이터 크기 줄이기
# train 데이터 줄이기
train_transaction = reduce_memory_use(train_transaction)
train_identity= reduce_memory_use(train_identity)

# test 데이터 줄이기
test_transaction = reduce_memory_use(test_transaction)
test_identity= reduce_memory_use(test_identity)

"""# 데이터 합치기"""

train_merged = pd.merge(train_transaction, train_identity, on='TransactionID', how='left')
test_merged = pd.merge(test_transaction, test_identity, on='TransactionID', how='left')

"""# Object / Numerical / Boolean 컬럼 분류"""

# train_merged 데이터셋에서 
# 데이터 타입별(object, int, float) 컬럼을 분류한다.
object_columns = []
numerical_columns = []
boolean_columns =[]

numerics=['int16','int32', 'int64', 'float16', 'float32', 'float64']


# train_merged는 isFraud가 있는반면 test_merged는 없다.
columns = test_merged.columns

for column in columns:
  column_dtype= train_merged[column].dtypes
  
  # 현재 컬럼의 데이터 타입이 문자열(String)이라면
  if column_dtype=='object':
    object_columns.append(column)
  
  # 현재 컬럼의 데이터 타입이 int/float이라면
  elif column_dtype in numerics:
    numerical_columns.append(column)
    
  # 현재 컬럼의 데이터 타입이 boolean이라면
  elif column_dypte=='boolean':
    boolean_columns.append(column)
    
print('\n---------------------------------------------')
print('numerical_columns(int64, float64) 개수: ', len(numerical_columns))
print('object_columns 개수: ', len(object_columns))
print('boolean_columns 개수: ', len(boolean_columns))

object_columns

# object_columns 에서 각 컬럼별 클래스 개수를 나타냈다.
for obj_col in object_columns:
  vcnt=train_merged[obj_col].value_counts()
  print('\n[{}]\n{}\n{} class 개수: {}'.format(obj_col, vcnt, obj_col, vcnt.nunique()))
  print('----------------------------------------------------\n')

"""위의 결과는 object 타입의 컬럼들을 대상으로 value_counts() 시킨 결과이다.

위의 결과를 보면 라벨 인코딩하기에 많은 클래스 수를 갖는 컬럼들이 존재한다. 클래스의 개수를 줄일 필요가 있다.

- P_emaildomain(56종류)
- R_emaildomain(55종류)
- id_30 (72종류)
- id_31 (103종류)
- id_33 (74종류)
- DeviceInfo(141종류)

# (1) P_emaildomain
"""

# gmail
train_merged.loc[ train_merged['P_emaildomain'].str.contains('gmail', na=False)]['P_emaildomain'].value_counts()

# yahoo
train_merged.loc[ train_merged['P_emaildomain'].str.contains('yahoo', na=False)]['P_emaildomain'].value_counts()

# outlook
train_merged.loc[train_merged['P_emaildomain'].str.contains('outlook',na=False), 'P_emaildomain'].value_counts()

# hotmail
train_merged.loc[train_merged['P_emaildomain'].str.contains('hotmail',na=False), 'P_emaildomain'].value_counts()

# live
train_merged.loc[train_merged['P_emaildomain'].str.contains('live',na=False), 'P_emaildomain'].value_counts()

# P_emaildomain의 클래스 중 데이터의 개수가 200개
# nunique() 는 컬럼에 속하는 클래스의 개수를 카운트할 때 사용..
train_merged.loc [ train_merged['P_emaildomain'].isin(
    train_merged.P_emaildomain.value_counts()[
        train_merged.P_emaildomain.value_counts()<=200].index), 'P_emaildomain' ]

"""# (2) R_emaildomain"""

# yahoo
train_merged.loc[train_merged['R_emaildomain'].str.contains('yahoo', na=False), 'R_emaildomain'].value_counts()

# hotmail
train_merged.loc[train_merged['R_emaildomain'].str.contains('hotmail', na=False), 'R_emaildomain'].value_counts()

# live
train_merged.loc[ train_merged['R_emaildomain'].str.contains('live', na=False), 'R_emaildomain'].value_counts()

# outlook
train_merged.loc[ train_merged['R_emaildomain'].str.contains('outlook', na=False), 'R_emaildomain'].value_counts()

"""# (3) id_30

위의 코드 결과를 보면, 이 컬럼에 존재하는 클래스들은 운영체제(OS) 종류를 나타낸다.

주로 많이 보이는 클래스 iOS, Android, Linux, Mac, Windows 로 보인다.

72개의 클래스 종류가 있으나 일부가 가려져있어서 보기가 어렵다.

(1) 잘보이는 클래스를 대상으로 그룹핑을 한다.

- ex. Mac OS X 10_12_4 , Mac Os X 10.9, ... ==> Mac OS X 
- ex. Windows XP, Windows 7, ...  ==> Windows


일단 아래 먼저 5개의 운영체제를 하나의 그룹으로 다시 묶는다.

- iOS
- Android
- Linux
- Mac OS X
- Windows
"""

# (1) iOS 그룹핑
train_merged.loc[ train_merged['id_30'].str.contains('iOS', na=False), 'id_30']='iOS'
train_merged.id_30.value_counts()

# (2) Mac/ Mac OS X => Mac으로  그룹핑
train_merged.loc[ train_merged['id_30'].str.contains('Mac', na=False), 'id_30']='Mac'
train_merged['id_30'].value_counts()

# (3) Android 그룹핑
train_merged.loc[ train_merged['id_30'].str.contains('Android', na=False), 'id_30']='Android'
train_merged['id_30'].value_counts()

# (4) Windows 그룹핑
train_merged.loc[ train_merged['id_30'].str.contains('Windows', na=False), 'id_30']='Windows'
train_merged['id_30'].value_counts()

"""# (4) id_31

id_31은 인터넷 브라우저에 대한 정보를 나타낸다.

103개의 클래스가 있다. 

제일 많이 보이는 인터넷 브라우저 이름은 아래의 4개이다.

먼저 아래의 4개를 하나로 통합시켜본다.

- chrome
- safari
- firefox
- Samsung(samsung)
"""

# (1) chrome 그룹핑
train_merged.loc[ train_merged['id_31'].str.contains('chrome', na=False), 'id_31'].value_counts()

train_merged.loc[ train_merged['id_31'].str.contains('chrome', na=False), 'id_31']= 'Chrome'
# google, google search application, chromium
train_merged.loc[ train_merged['id_31'].isin(['google','google search application 48.0', 
                                              'google search application 49.0','chromium', 'Google']), 'id_31']='Chrome'
train_merged['id_31'].value_counts()

# (2) safari
train_merged.loc[ train_merged['id_31'].str.contains('safari', na=False), 'id_31']='Safari'
train_merged['id_31'].value_counts()

# (3) opera
train_merged.loc[ train_merged['id_31'].str.contains('opera', na=False), 'id_31']='Opera'
train_merged['id_31'].value_counts()

# (4) edge
#train_merged.loc[train_merged['id_31'].str.contains('edge', na=False), 'id_31']='MicroSoft'

train_merged.loc[ train_merged['id_31']=='Edge', 'id_31']='MicroSoft'
# Microsoft/Windows 
train_merged.loc[ train_merged['id_31'].str.contains('Microsoft/Windows', na=False), 'id_31']='MicroSoft'
train_merged['id_31'].value_counts()

# (5) ie
train_merged.loc[ train_merged['id_31'].str.contains('ie', na=False), 'id_31']='IE'
train_merged['id_31'].value_counts()

# (6) firefox
train_merged.loc[ train_merged['id_31'].str.contains('firefox', na=False), 'id_31' ]='FireFox'
# Mozilla/FireFox 도 같이 합친다.
train_merged.loc[ train_merged['id_31'].isin(['Mozilla/Firefox']), 'id_31']='FireFox'
train_merged['id_31'].value_counts()

# (7) samsung
train_merged.loc[ train_merged['id_31'].str.contains('samsung', na=False) , 'id_31'  ]= 'Samsung'
train_merged.loc[ train_merged['id_31'].isin(['Samsung/SM-G532M', 
                                              'Samsung/SM-G531H', 
                                              'Samsung/SCH']), 'id_31']='Samsung'
train_merged['id_31'].value_counts()

# (8) Android
train_merged.loc[ train_merged['id_31'].isin(['android browser 4.0', 'Generic/Android 7.0', 'Generic/Android', 'android']), 'id_31']='Android'
train_merged['id_31'].value_counts()

train_merged.loc[ train_merged['id_31'].isin( train_merged.id_31.value_counts().loc[train_merged['id_31'].value_counts().values<=100].index), 'id_31'] ='Others'
train_merged.id_31.value_counts()

"""# id_33

화면의 해상도를 나타내는 것 같다.

여기서는 id_30, id_31 처럼 그룹 라벨링을 하지않고 

개수가 500개 미만인 것들을 OtherSize 로 통합시킨다.
"""

train_merged.loc[ train_merged['id_33'].isin(
  train_merged.id_33.value_counts().loc[ train_merged['id_33'].value_counts().values<=500].index), 'id_33'] ='OtherSize'

train_merged.id_33.value_counts()

"""# DeviceInfo

object(string) 타입의 데이터를 갖는 컬럼들 중 가장많은 클래스를 갖고있다. (141개)

컴퓨터와같은 기기의 정보를 나타낸다.

- ex) SM, SAMSUNG  → SAMSUNG

- ex) rv:58.0, rv:52.0 →  rv
"""

# (1) Samsung
train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('SM' , na=False)] = 'Samsung'
train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].isin(['SAMSUNG'])]= 'Samsung'
train_merged.DeviceInfo.value_counts()

# (2) LG
train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('LG', na=False)]='LG'
train_merged.DeviceInfo.value_counts()

# (3) rv
train_merged.loc[ train_merged['DeviceInfo'].str.contains('rv', na=False), 'DeviceInfo']= 'RV'
train_merged.DeviceInfo.value_counts()

# (4) Moto
train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('Moto', na=False)]='Moto'
train_merged.DeviceInfo.value_counts()

# (5) Huawel
train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('HUAWEI',na=False)]='Huawei'
train_merged.loc[train_merged['DeviceInfo'].isin(['ALE-L23 Build/HuaweiALE-L23']) , 'DeviceInfo']= 'Huawei'
train_merged.DeviceInfo.value_counts()

# Others (200개 적은 클래스들을 통합.)
train_merged.loc[ train_merged['DeviceInfo'].isin(
 train_merged.DeviceInfo.value_counts().loc[ train_merged['DeviceInfo'].value_counts().values<= 200].index 
), 'DeviceInfo']='Others'

train_merged.DeviceInfo.value_counts()

"""# Feature Engineering-ObjectColumns

각 object column에 해당하는 클래스의 개수를 줄인다.
"""

# Commented out IPython magic to ensure Python compatibility.
def object_feature_engineering(df):
  # P_emaildomain
  df.loc[df['P_emaildomain'].isin(['gmail.com', 'gmail']), 'P_emaildomain']='Gmail'
  
  df.loc[df['P_emaildomain'].isin(['yahoo.com', 'yahoo.com.mx',\
                                                       'yahhoo.es','yahoo.fr',\
                                                       'yahoo.de', 'yahoo.co.uk', \
                                                       'yahoo.co.jp' ]), 'P_emaildomain']='Yahoo'
  
  df.loc[ df['P_emaildomain'].isin(['outlook.com', 'outlook.es']),'P_emaildomain']='Outlook'

  df.loc[ df['P_emaildomain'].isin(['hotmail.com','hotmail.es', 'hotmail.fr', \
                                    'hotmail.co.uk', 'hotmail.de']),'P_emaildomain']='Hotmail'
  
  df.loc[ df['P_emaildomain'].isin(['mac.com', 'icloud.com']), 'P_emaildomain']='Apple'
  
  df.loc[ df['P_emaildomain'].isin(['live.com', 'live.com.mx', 'live.fr']), 'P_emaildomain']='Live'
  
  ## P_emaildomain 중 500개 미만인 것들은 Others로 합친다.
  df.loc[ df['P_emaildomain'].isin( 
      df.P_emaildomain.value_counts()[
          df.P_emaildomain.value_counts()<=500].index), 'P_emaildomain']='Others'
  
  # #################################################################################
  # R_emaildomain
  df.loc[df['R_emaildomain'].isin(['gmail',' gmail.com']), 'R_emaildomain']='Gmail'
  
  df.loc[df['R_emaildomain'].isin(['yahoo.com', 'yahoo.com.mx', 'yahoo.es', 'yahoo.de', \
                                   'yahoo.co.uk', 'yahoo.fr', 'yahoo.co.jp']), 'R_emaildomain']='Yahoo'
  
  df.loc[df['R_emaildomain'].isin(['outlook.com', 'outlook.es']), 'R_emaildomain']='Outlook'
  
  df.loc[df['R_emaildomain'].isin(['hotmail.com', 'hotmail.fr', 'hotmail.es',\
                                   'hotmail.co.uk', 'hotmail.de']), 'R_emaildomain']='Hotmail'
  
  df.loc[df['R_emaildomain'].isin(['icloud.com', 'mac.com']), 'R_emaildomain']='Apple'
  
  df.loc[df['R_emaildomain'].isin(['live.com', 'live.com.mx', 'live.fr']), 'R_emaildomain']='Live'
  
  # R_emaildomain 중 500개 미만인 것들은 Others로 합친다.
  df.loc[ df['R_emaildomain'].isin( 
      df.R_emaildomain.value_counts()[
          df.R_emaildomain.value_counts()<=500].index), 'R_emaildomain']='Others'
  
  # #################################################################################
  # id_30
  ## iOS
  df.loc[ df['id_30'].str.contains('iOS', na=False), 'id_30']='iOS'
  
  ## Mac, Mac OS X
  df.loc[ df['id_30'].str.contains('Mac', na=False), 'id_30']='Mac'
  
  ## Android
  df.loc[ df['id_30'].str.contains('Android', na=False), 'id_30']='Android'
  
  ## Windows
  df.loc[ df['id_30'].str.contains('Windows', na=False), 'id_30']='Windows'
  
  # #################################################################################
  # id_31
  ## chrome, google search application
  df.loc[ df['id_31'].str.contains('chrome', na=False), 'id_31']='Chrome'
  df.loc[ df['id_31'].isin(['google','google search application 48.0', \
                                                'google search application 49.0','chromium']), 'id_31']='Chrome'
  
  ## safari
  df.loc[ df['id_31'].str.contains('safari', na=False), 'id_31']='Safari'
  
  ## firefox, mozila
  df.loc[ df['id_31'].str.contains('firefox', na=False), 'id_31']='Firefox'
  df.loc[ df['id_31'].isin(['Mozilla/Firefox']), 'id_31']='FireFox'
  
  ## samsung
  df.loc[ df['id_31'].str.contains('samsung', na=False) , 'id_31']= 'Samsung'
  df.loc[ df['id_31'].isin(['Samsung/SM-G532M','Samsung/SM-G531H', 'Samsung/SCH']), 'id_31']='Samsung'
  
  ## ie
  df.loc[ df['id_31'].str.contains('ie', na=False), 'id_31']='IE'
  
  ## Edge
  df.loc[ df['id_31'].str.contains('Edge', na=False), 'id_31']='MicroSoft'
  df.loc[ df['id_31'].str.contains('Microsoft/Windows', na=False), 'id_31']='MicroSoft'
  
  ## Opera
  df.loc[ df['id_31'].str.contains('opera', na=False), 'id_31']='Opera'
  
  ## Android
  df.loc[ df['id_31'].isin(['android browser 4.0', 'Generic/Android 7.0', 'Generic/Android', 'android']), 'id_31']='Android'
  
  ## 100개 미만인 브라우저 클래스는 Others로 한다.
  df.loc[ df['id_31'].isin(df.id_31.value_counts().loc[ df['id_31'].value_counts().values<=100].index), 'id_31'] ='Others'
   
  # #################################################################################
  # id_33
  # 500개 미만의 해상도 클래스는 OtherSize로 한다.
  df.loc[ df['id_33'].isin( df.id_33.value_counts().loc[ df['id_33'].value_counts().values<=500].index), 'id_33']='OtherSize'
  
  # #################################################################################
  # DeviceInfo
  ## Samsung
  train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('SM' , na=False)] = 'Samsung'
  train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].isin(['SAMSUNG'])]= 'Samsung'
  train_merged.DeviceInfo.value_counts()
  
  ## LG
  train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('LG', na=False)]='LG'
  
  ## RV
  train_merged.loc[ train_merged['DeviceInfo'].str.contains('rv', na=False), 'DeviceInfo']= 'RV'
  
  ## Moto
  train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('Moto', na=False)]='Moto'
  
  ## Huawei
  train_merged['DeviceInfo'].loc[ train_merged['DeviceInfo'].str.contains('HUAWEI',na=False)]='Huawei'
  train_merged.loc[train_merged['DeviceInfo'].isin(['ALE-L23 Build/HuaweiALE-L23']) , 'DeviceInfo']= 'Huawei'
  
  ## Others (100개 미만일 경우의 클래스들)
  train_merged.loc[ train_merged['DeviceInfo'].isin(
  train_merged.DeviceInfo.value_counts().loc[ train_merged['DeviceInfo'].value_counts().values<= 200].index), 'DeviceInfo']='Others'
  
  return df

train_merged=object_feature_engineering(train_merged)
# %time

# test_merged 데이터셋 또한 미리 labeling 하기 좋은 형태로 바꾼다.
test_merged= object_feature_engineering(test_merged)

"""# Feature Engineering - Null, NaN값 채우기."""

# Object 데이터 타입 컬럼에서 NaN값 대신에 다른 string으로 대신하기
def fill_nan(df, obj_columns):
  features= obj_columns
  
  for feature in features:
    df[feature].fillna( 'None', inplace=True)
  
  return df

train_merged=fill_nan(train_merged, object_columns)

train_merged.P_emaildomain.value_counts()

train_merged.R_emaildomain.value_counts()

train_merged.id_30.value_counts()

train_merged.id_31.value_counts()

train_merged.DeviceInfo.value_counts()

"""# LabelEncoding"""

from sklearn.preprocessing import LabelEncoder

def labelEncoding_features(df, obj_columns):
  # object_columns에 해당하는 컬럼을 레이블인코딩 수행..
  # LabelEncoder를 객체로 생성한 후 fit()과 transform()으로 레이블 인코딩 수행
  features = obj_columns
  
  for feature in features:
    le= LabelEncoder()
    le = le.fit(df[feature])
    df[feature]=le.transform(df[feature])
  
  return df

# label encoder 함수를 이용하여 object를 숫자타입으로 변환시키자.
train_merged= labelEncoding_features(train_merged, object_columns)

"""# Modeling - LightGBM(LGBM)"""

# 훈련데이터 셋
y_train = train_merged['isFraud']
X_train = train_merged.drop([ 'TransactionID', 'isFraud'], axis=1)

# 훈련데이터셋에서 학습용(pre_X/y_train), 시험용(pre_X/y_test) 으로 나눈다.
pre_X_train, pre_X_test, pre_y_train, pre_y_test = train_test_split(X_train, 
                                                                    y_train, 
                                                                    test_size=0.2, 
                                                                    random_state=156)


# lgbm 모델 클래스를 부른다.
lgbm_clf = LGBMClassifier(n_estimators=500) # 500번 학습..
evals = [ (pre_X_test, pre_y_test)]
lgbm_clf.fit(pre_X_train, 
             pre_y_train, 
             early_stopping_rounds=100,
             eval_metric='auc',
             eval_set=evals,
             verbose=True
            )

pre_lgbm_roc_score = roc_auc_score(pre_y_test, lgbm_clf.predict_proba(pre_X_test)[:,1], average='macro')
print('pre-training-ROC AUC: {:.4f}'.format(pre_lgbm_roc_score))

# test_merged 데이터셋의 object컬럼을 라벨인코딩 시키고..
test_merged= labelEncoding_features(test_merged, object_columns)

# test_merged 데이터셋의 object컬럼중 null/nan값을 채우고..
test_merged=fill_nan(test_merged, object_columns)
test_transactionID= test_merged['TransactionID']

X_test = test_merged.drop('TransactionID', axis=1)

# 테스트 데이터셋 예측결과 - submission파일의 isFraud 에 해당.
lgbm_pred = lgbm_clf.predict_proba(X_test)[:,1]

#결과 데이터 프레임을 생성한다.
data= { 'TransactionID': test_transactionID, 
       'isFraud': lgbm_pred
      }
lgbm_result = pd.DataFrame(data)

# 데이터의 크기를 줄인다.
lgbm_result=reduce_memory_use(lgbm_result)

# lgbm_result={ 'TransactionID': test_transactionID,
#               'isFraud': lgbm_pred
#             }
# lgbm_result= pd.DataFrame(lgbm_result)



# csv파일을 생성한다.
lgbm_result.to_csv('lgbm_submission.csv', index=False)

!ls

!cp lgbm_submission.csv "/content/gdrive/My Drive/."

!ls "/content/gdrive/My Drive/"